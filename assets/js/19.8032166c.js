(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{380:function(n,v,_){"use strict";_.r(v);var S=_(25),t=Object(S.a)({},(function(){var n=this,v=n.$createElement,_=n._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[_("h2",{attrs:{id:"一、数据传输指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、数据传输指令"}},[n._v("#")]),n._v(" "),_("strong",[n._v("一、数据传输指令")])]),n._v(" "),_("p",[n._v("它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据.")]),n._v(" "),_("p",[n._v("\\1. 通用数据传送指令.\nMOV 传送字或字节.\nMOVSX 先符号扩展,再传送.\nMOVZX 先零扩展,再传送.\nPUSH 把字压入堆栈.\nPOP 把字弹出堆栈.\nPUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈.\nPOPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈.\nPUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈.\nPOPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈.\nBSWAP 交换32位寄存器里字节的顺序\nXCHG 交换字或字节.( 至少有一个操作数为寄存器,段寄存器不可作为操作数)\nCMPXCHG 比较并交换操作数.( 第二个操作数必须为累加器AL/AX/EAX )\nXADD 先交换再累加.( 结果在第一个操作数里 )\nXLAT 字节查表转换.\n-- BX 指向一张 256 字节的表的起点, AL 为表的索引值 (0-255,即 0-FFH); 返回 AL 为查表结果. ( [BX+AL]->AL )")]),n._v(" "),_("p",[n._v("\\2. 输入输出端口传送指令.\n"),_("strong",[n._v("IN")]),n._v(" I/O端口输入. ( 语法: "),_("strong",[n._v("IN")]),n._v(" 累加器, {端口号│DX} )\n"),_("strong",[n._v("OUT")]),n._v(" I/O端口输出. ( 语法: "),_("strong",[n._v("OUT")]),n._v(" {端口号│DX},累加器 )\n输入输出端口由立即方式指定时, 其范围是 0-255; 由寄存器 DX 指定时,\n其范围是 0-65535.")]),n._v(" "),_("p",[n._v("\\3. 目的地址传送指令.\nLEA 装入有效地址.\n例: LEA DX,"),_("strong",[n._v("string")]),n._v(" ;把偏移地址存到DX.\nLDS 传送目标指针,把指针内容装入DS.\n例: LDS SI,"),_("strong",[n._v("string")]),n._v(" ;把段地址:偏移地址存到DS:SI.\nLES 传送目标指针,把指针内容装入ES.\n例: LES DI,"),_("strong",[n._v("string")]),n._v(" ;把段地址:偏移地址存到ES:DI.\nLFS 传送目标指针,把指针内容装入FS.\n例: LFS DI,"),_("strong",[n._v("string")]),n._v(" ;把段地址:偏移地址存到FS:DI.\nLGS 传送目标指针,把指针内容装入GS.\n例: LGS DI,"),_("strong",[n._v("string")]),n._v(" ;把段地址:偏移地址存到GS:DI.\nLSS 传送目标指针,把指针内容装入SS.\n例: LSS DI,"),_("strong",[n._v("string")]),n._v(" ;把段地址:偏移地址存到SS:DI.")]),n._v(" "),_("p",[n._v("\\4. 标志传送指令.\nLAHF 标志寄存器传送,把标志装入AH.\nSAHF 标志寄存器传送,把AH内容装入标志寄存器.\nPUSHF 标志入栈.\nPOPF 标志出栈.\nPUSHD 32位标志入栈.\nPOPD 32位标志出栈.")]),n._v(" "),_("h2",{attrs:{id:"二、算术运算指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、算术运算指令"}},[n._v("#")]),n._v(" "),_("strong",[n._v("二、算术运算指令")])]),n._v(" "),_("p",[n._v("ADD 加法.\nADC 带进位加法.\nINC 加 1.\nAAA 加法的ASCII码调整.\nDAA 加法的十进制调整.\nSUB 减法.\nSBB 带借位减法.\nDEC 减 1.\nNEC 求反(以 0 减之).\nCMP 比较.(两操作数作减法,仅修改标志位,不回送结果).\nAAS 减法的ASCII码调整.\nDAS 减法的十进制调整.\nMUL 无符号乘法.\nIMUL 整数乘法.\n以上两条,结果回送AH和AL(字节运算),或DX和AX(字运算),\nAAM 乘法的ASCII码调整.\n"),_("strong",[n._v("DIV")]),n._v(" 无符号除法.\nIDIV 整数除法.\n以上两条,结果回送:商回送AL,余数回送AH, (字节运算); 或 商回送AX,余数回送DX, (字运算).\nAAD 除法的ASCII码调整.\nCBW 字节转换为字. (把AL中字节的符号扩展到AH中去)\nCWD 字转换为双字. (把AX中的字的符号扩展到DX中去)\nCWDE 字转换为双字. (把AX中的字符号扩展到EAX中去)\nCDQ 双字扩展. (把EAX中的字的符号扩展到EDX中去)")]),n._v(" "),_("h2",{attrs:{id:"三、逻辑运算指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、逻辑运算指令"}},[n._v("#")]),n._v(" "),_("strong",[n._v("三、逻辑运算指令")])]),n._v(" "),_("p",[_("strong",[n._v("AND")]),n._v(" 与运算.\n"),_("strong",[n._v("OR")]),n._v(" 或运算.\nXOR 异或运算.\n"),_("strong",[n._v("NOT")]),n._v(" 取反.\nTEST 测试.(两操作数作与运算,仅修改标志位,不回送结果).\n"),_("strong",[n._v("SHL")]),n._v(" 逻辑左移.\nSAL 算术左移.(="),_("strong",[n._v("SHL")]),n._v(")\n"),_("strong",[n._v("SHR")]),n._v(" 逻辑右移.\nSAR 算术右移.(="),_("strong",[n._v("SHR")]),n._v(")\nROL 循环左移.\nROR 循环右移.\nRCL 通过进位的循环左移.\nRCR 通过进位的循环右移.\n以上八种移位指令,其移位次数可达255次.\n移位一次时, 可直接用操作码. 如 "),_("strong",[n._v("SHL")]),n._v(" AX,1.\n移位>1次时, 则由寄存器CL给出移位次数.\n如 MOV CL,04\n"),_("strong",[n._v("SHL")]),n._v(" AX,CL")]),n._v(" "),_("h2",{attrs:{id:"四、串指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四、串指令"}},[n._v("#")]),n._v(" "),_("strong",[n._v("四、串指令")])]),n._v(" "),_("p",[n._v("DS:SI 源串段寄存器 :源串变址.\nES:DI 目标串段寄存器:目标串变址.\nCX 重复次数计数器.\nAL/AX 扫描值.\nD标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量.\nZ标志 用来控制扫描或比较操作的结束.\nMOVS 串传送.\n( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. )\nCMPS 串比较.\n( CMPSB 比较字符. CMPSW 比较字. )\nSCAS 串扫描.\n把AL或AX的内容与目标串作比较,比较结果反映在标志位.\nLODS 装入串.\n把源串中的元素(字或字节)逐一装入AL或AX中.\n( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. )\nSTOS 保存串.\n是LODS的逆过程.\nREP 当CX/ECX<>0时重复.\nREPE/REPZ 当ZF=1或比较结果相等,且CX/ECX<>0时重复.\nREPNE/REPNZ 当ZF=0或比较结果不相等,且CX/ECX<>0时重复.\nREPC 当CF=1且CX/ECX<>0时重复.\nREPNC 当CF=0且CX/ECX<>0时重复.")]),n._v(" "),_("h2",{attrs:{id:"五、程序转移指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#五、程序转移指令"}},[n._v("#")]),n._v(" "),_("strong",[n._v("五、程序转移指令")])]),n._v(" "),_("p",[n._v("1>无条件转移指令 (长转移)\nJMP 无条件转移指令\nCALL 过程调用\nRET/RETF过程返回.")]),n._v(" "),_("p",[n._v("2>条件转移指令 (短转移,-128到+127的距离内)\n( 当且仅当(SF XOR "),_("strong",[n._v("OF")]),n._v(")=1时,OP1<OP2 )\nJA/JNBE 不小于或不等于时转移.\nJAE/JNB 大于或等于转移.\nJB/JNAE 小于转移.\nJBE/JNA 小于或等于转移.\n以上四条,测试无符号整数运算的结果(标志C和Z).\nJG/JNLE 大于转移.\nJGE/JNL 大于或等于转移.\nJL/JNGE 小于转移.\nJLE/JNG 小于或等于转移.\n以上四条,测试带符号整数运算的结果(标志S,O和Z).\nJE/JZ 等于转移.\nJNE/JNZ 不等于时转移.\nJC 有进位时转移.\nJNC 无进位时转移.\nJNO 不溢出时转移.\nJNP/JPO 奇偶性为奇数时转移.\nJNS 符号位为 “0” 时转移.\nJO 溢出转移.\nJP/JPE 奇偶性为偶数时转移.\nJS 符号位为 “1” 时转移.")]),n._v(" "),_("p",[n._v("3>循环控制指令(短转移)\nLOOP CX不为零时循环.\nLOOPE/LOOPZ CX不为零且标志Z=1时循环.\nLOOPNE/LOOPNZ CX不为零且标志Z=0时循环.\nJCXZ CX为零时转移.\nJECXZ ECX为零时转移.")]),n._v(" "),_("p",[n._v("4>中断指令\nINT 中断指令\nINTO 溢出中断\nIRET 中断返回")]),n._v(" "),_("p",[n._v("5>处理器控制指令\nHLT 处理器暂停, 直到出现中断或复位信号才继续.\nWAIT 当芯片引线TEST为高电平时使CPU进入等待状态.\nESC 转换到外处理器.\nLOCK 封锁总线.\nNOP 空操作.\nSTC 置进位标志位.\nCLC 清进位标志位.\nCMC 进位标志取反.\nSTD 置方向标志位.\nCLD 清方向标志位.\nSTI 置中断允许位.\nCLI 清中断允许位.")]),n._v(" "),_("p",[_("strong",[n._v("六、伪指令")])]),n._v(" "),_("hr"),n._v(" "),_("p",[n._v("DW 定义字(2字节).\nPROC 定义过程.\nENDP 过程结束.\nSEGMENT 定义段.\nASSUME 建立段寄存器寻址.\nENDS 段结束.\n"),_("strong",[n._v("END")]),n._v(" 程序结束.")])])}),[],!1,null,null,null);v.default=t.exports}}]);